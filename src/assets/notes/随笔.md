# 测试

#### 1.用户点击的事件方法以on为前缀  
    handleClick()

#### 2.  


     const msg = err && typeof err === 'object' ? err.msg || err.errorMsg || err.message || JSON.stringify(err) : `${err}`
     Toast(msg)
     console.log("errorHandler =>",err, info)

err 如果为null值, null.msg会报错

```shell
VM7565:1 Uncaught TypeError: Cannot read properties of null (reading 'msg')
at <anonymous>:1:3
```


#### 3.关于深度作用选择器 /deep/ 的说明  

为了保证每个组件的css唯一性，避免污染全局或者被全局污染，vue提供了`scoped`作用域,但如果想在单独页面中修改样式但不影响全局的组件样式，可以用`/deep/`穿透`scoped`

#### 4.img的src应该使用require()的方式存放  

```vue
<img :src="require('')" alt="">
```
这里涉及到了webpack

HTML的img标签的src是有两种, 绝对路径/相对路径, 相对路径可以转成绝对路径  

Vue项目一般都会经过Webpack之类的打包工具, 在解析template里面, 解析img标签的时候, 如果src是静态字符串, 如果不是http开头的, 那么就是相对于源码目录的图片  

那么如果把src设置为一个变量, 那么template里解析img标签的时候并不知道src的值, 是不是http开头的, 需要运行时才知道, 所以需要你告诉构建工具, 项目使用了这个图片资源, 然后返回相对于web服务器根目录的路径(dist目录也行)

require('xx.jpg')的作用就是把图片复制到dist目录下的某个目录(根据你的配置), 然后返回相对web服务器根目录的相对路径字符串, 这个是构建时就返回了  

#### 5.关于main.js中的import

```vue
;(s => s.keys().forEach(k => s(k).default && Vue.use(s(k).default)))(require.context('./plugins', true, /\.js$/));
```
```vue
function dd(s){
  s.keys().forEach(k => s(k).default && Vue.use(s(k).default)))
}
dd((require.context('./plugins', true, /\.js$/))
```
`Object.keys().forEach()`对象的遍历

#### 6.关于函数柯里化与数组扁平化

##### 1.概念  

函数柯里化指封装一个函数，接收原始函数作为参数传入，并返回一个能够接收并处理剩余参数的函数

以add函数为例：
```javascript
// 普通的add函数
function add(x, y) {
    return x + y
}

// 柯里化后
function curryingAdd(x) {
    return function (y) {
        return x + y
    }
}

add(1, 2)           // 3
curryingAdd(1)(2)   // 3
```
实际上就是把add函数的x，y两个参数变成了先用一个函数接收x然后返回一个函数去处理y参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。  

##### 2.柯里化的优点

###### （1）参数复用  
```javascript
// 正常正则验证字符串 reg.test(txt)

// 函数封装后
function check(reg, txt) {
    return reg.test(txt)
}

check(/\d+/g, 'test')       //false
check(/[a-z]+/g, 'test')    //true

// Currying后
function curryingCheck(reg) {
    return function(txt) {
        return reg.test(txt)
    }
}

var hasNumber = curryingCheck(/\d+/g)
var hasLetter = curryingCheck(/[a-z]+/g)

hasNumber('test1')      // true
hasNumber('testtest')   // false
hasLetter('21212')      // false

```  
如果有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便  

###### （2）延迟执行   


###### （3）提前返回  

##### 3.柯里化的缺点  

###### （1）存取 arguments 对象要比存取命名参数要慢一些
###### （2）老版本浏览器在 arguments.lengths 的实现相当慢(新版本浏览器忽略)
###### （3）fn.apply() 和 fn.call() 要比直接调用 fn() 慢
###### （4）大量嵌套的作用域和闭包会带来开销，影响内存占用和作用域链查找速度

[参考文章1](https://blog.csdn.net/yexudengzhidao/article/details/98522300)  
[参考文章2](https://segmentfault.com/a/1190000017981474)

#### 7.JS中使用&&语句
`&&` 表示与运算

譬如下面这条语句：

        index > -1 && photoList.splice( index, 1, photo )

这条语句可以转换为

        if ( index > -1 ) { photoList.splice( index, 1, photo ) }  

因为`{ }`内的语句需要在`if`语句中条件成立时才生效，即`index>-1`为`true`。`&&`运算符有相同效果，只有两个表达式都为`true`时才能返回`true`，反之返回`false`。
因此可以省略成上面的写法，这可以算是一种技巧

#### 8.bind、apply、call的区别  

bind，call，apply的作用都是用来改变this指向

###### apply方法  
apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以**数组的形式**传入，且当第一个参数为null、undefined的时候，默认指向window(在浏览器中)，使用apply方法改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次。  

###### call方法
call方法的第一个参数也是this的指向，后面传入的是一个**参数列表**（注意和apply传参的区别）。当一个参数为null或undefined的时候，表示指向window（在浏览器中），和apply一样，call也只是临时改变一次this指向，并立即执行。  

###### bind方法
bind方法和call很相似，第一参数也是this的指向，后面传入的也是一个**参数列表(但是这个参数列表可以分多次传入，call则必须一次性传入所有参数)**，但是它改变this指向后不会立即执行，而是**返回一个永久改变this指向的函数**。  

##### 三者的区别

+ 三者都可以改变函数的this对象指向。
+ 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。
+ 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。
+ bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 。

#### 9.VueX

![Vuex状态图](../../assets/image/vuex.png)

首先，`Vue`组件如果调用某个`VueX`的方法过程中需要向后端请求时或者说出现异步操作时，需要`dispatch` VueX中`actions`的方法，以保证数据的同步。可以说，`action`的存在就是为了让`mutations`中的方法能在异步操作中起作用。

##### State 存储状态(变量)

在state中定义的变量可以在任意组件中使用


##### Mutations
`mutations`是操作`state`数据的方法的集合，比如对该数据的修改、增加、删除等等。
###### Mutations的使用方法

`mutations`方法都有默认的形参：(**[state] ,[payload]**)

+ `state`是当前`VueX`对象中的`state`
+ `payload`是向`store.commit`传入额外的参数，即该方法在被调用时传递参数使用的

###### Mutations传值

##### Action 

Action类似于Mutation，不同在于：  
- Action提交的是mutation，而不是直接变更状态
- Action可以包含任意异步操作，譬如

###### 分发Action
Action 通过`store.dispatch`方法触发
在组件中使用：
```javascript
//载荷模式
this.$store.dispatch('action方法名',参数)

//对象模式
this.$store.dispatch({type:'action方法名',参数})

```
通过`mapActions`使用：
```javascript
//如果没有使用模块化开发则不需要加上 'modules模块名'
...mapActions('modules模块名', ['模块下的action方法名'])
this.action方法名(参数)
```

##### Modules

**注意**

在使用Modules模块化开发时，每个模块在暴露时都应加上`namespaced: true` ,这种方式使其成为带命名空间的模块。保证在变量名一样的时候，添加一个父级名拼接。
```javascript
export default {
    namespaced:true,
    state,
    mutations,
    actions
}
```
###### mapstate
当使用Modules模块化写法时，mapState需要在组件中的computed属性中使用，具体写法如下
```vue
<script>
import {mapState} from 'vuex'
export default {
  computed:{
    ...mapState({count2:state => state.test.count2 ,count:state => state.test.count}),
  },
</script>

```


#### 10. 特殊注释 TODO、FIXME、XXX